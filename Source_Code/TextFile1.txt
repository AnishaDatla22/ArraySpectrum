int	nWidth = 0;
	int	nHeight = 0;
	int	nImageSize = 0;
	int	nFrameCount = 10;
	int	nBitSize = 0;
	BOOL bStat = FALSE;
	LONG lDevCount = 0;
	BOOL bValue = TRUE;
	BOOL bValue2 = TRUE;
	INT nDevID = 0;
    //Note get nDevID??
	
	// Set trigger mode
	BYTE btValue = 0;	// Internal Sync Mode
	bStat = DcIc_SetTriggerMode(nDevID, btValue);
	if (bStat == FALSE)
	{
		// Change trigger mode is failed -> Exit this function
		OnConnectOrDisconnect();
		return;
	}
	// Set trigger polarity
	bValue = TRUE;		// High Active
	bStat = DcIc_SetTriggerPolarity(nDevID, bValue);
	if (bStat == FALSE)
	{
		// Change trigger polarity is failed -> Exit this function
		OnConnectOrDisconnect();
		return;
	}

	// Set trigger effective
	bValue = FALSE;	// Disable
	bStat = DcIc_SetTriggerEffective(nDevID, bValue);
	if (bStat == FALSE)
	{
		// Change trigger effective is failed -> Exit this function
		OnConnectOrDisconnect();
		return;
	}

	// Set Integration cycle(= Exposure time)
	DWORD dwValue = 1000;
	bStat = DcIc_SetStartPulseTime(nDevID, dwValue);
	if (bStat == FALSE)
	{
		//// Change exposure time is failed -> Exit this function
		//DcIc_Disconnect(nDevID);
		//DcIc_Terminate();	// Terminate process of library.
		//return;
	}
	// Set GAIN
	btValue = 2;
	bStat = DcIc_SetGain(nDevID, btValue);
	if (bStat == FALSE)
	{
		// Change GAIN value is failed -> Exit this function
		OnConnectOrDisconnect();
		return;
	}
	// set OFFSET
	WORD wValue = 0;
	bStat = DcIc_SetOffset(nDevID, wValue);
	if (bStat == FALSE)
	{
		// Change OFFSET value is failed -> Exit this function
		OnConnectOrDisconnect();
		return;
	}


	wValue = 32;
	bStat = DcIc_SetVerticalPixel(nDevID, wValue);
	if (bStat == FALSE)
	{
		// Change vertical pixel size is failed -> Exit this function
		OnConnectOrDisconnect();
		return;
	}


	// Create capture buffer.
	INT nFramCnt = 1;
	ULONG ulTotalPixels = 0;
	WORD wPixels = 0;
	WORD wLines = 0;

	bStat = DcIc_GetVerticalPixel(nDevID, &wLines);
	if (bStat == FALSE)
	{
		// Change vertical pixel size is failed -> Exit this function
		OnConnectOrDisconnect();
		return;
	}

	bStat = DcIc_GetHorizontalPixel(nDevID, &wPixels);
	if (bStat == FALSE)
	{
		// Change vertical pixel size is failed -> Exit this function
		OnConnectOrDisconnect();
		return;
	}
	ulTotalPixels = (ULONG)nFramCnt * (ULONG)wLines * (ULONG)wPixels;

	WORD* pwMeasBuff = NULL;
	TRY
	{
		pwMeasBuff = new WORD[ulTotalPixels];
		memset(pwMeasBuff, 0x00, ulTotalPixels * sizeof(WORD));
	}
		CATCH(CMemoryException, e)
	{
		// Failed -> Exit this function
		if (pwMeasBuff != NULL)
		{
			delete[] pwMeasBuff;
			pwMeasBuff = NULL;
		}
		OnConnectOrDisconnect();
		return;
	}
	END_CATCH

	// Start Acquisition
	bStat = DcIc_Capture(nDevID, pwMeasBuff, ulTotalPixels * sizeof(WORD));
	if (bStat == FALSE)
	{
		// Capture start failed -> Exit this function
		if (pwMeasBuff != NULL)
		{
			delete[] pwMeasBuff;
			pwMeasBuff = NULL;
		}
		OnConnectOrDisconnect();
		return;
	}

	// Wait to complete the capture image
	INT nRsltStat = DcIc_WAITSTATUS_CAPTURING;
	while (TRUE)
	{
		::Sleep(1000);
		nRsltStat = DcIc_Wait(nDevID);
		if (nRsltStat == DcIc_WAITSTATUS_CAPTURED)
		{
			// Data process
			SaveData("Sample.csv", pwMeasBuff, wPixels, wLines, nFrameCount, 0);
			break;
		}
	}

	// Process for exit. 
	bStat = DcIc_Abort(nDevID);
	if (pwMeasBuff != NULL)
	{
		delete[] pwMeasBuff;
		pwMeasBuff = NULL;
	}